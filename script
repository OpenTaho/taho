#!/bin/bash
#
# Taho Script
#
# Executes a Taho subcommand

# shellcheck disable=SC1090
# shellcheck disable=SC1091
# shellcheck disable=SC2001
# shellcheck disable=SC2013
# shellcheck disable=SC2016
# shellcheck disable=SC2059
# shellcheck disable=SC2116
# shellcheck disable=SC2126
# shellcheck disable=SC2139

# Setup colors
c0='\033[0m'    # No color
c1='\033[0;32m' # Green
c2='\033[0;31m' # Red

# We need Terragrunt to be non interactive.
export TG_NON_INTERACTIVE=true

#######################################
# Run the aws-runas subcommand
# Arguments:
#   TBD
# Returns
#   0 if successfully, non-zero on error.
#######################################
aws_runas() {
  local aws_runas_profile="$1"; shift
  local time="$1"; shift
  if [ -z "$time" ]; then
    if [[ "$aws_runas_profile" =~ .*-pu ]]; then
      time="4h"
    elif [[ "$aws_runas_profile" =~ .*-ro ]]; then
      time="4h"
    else
      time="1h"
    fi
  fi

  rm -rf ~/.aws/.aws_saml_* > /dev/null 2>&1
  echo 'unset AWS_ACCESS_KEY_ID'
  echo 'unset AWS_DEFAULT_REGION'
  echo 'unset AWS_REGION'
  echo 'unset AWS_SECRET_ACCESS_KEY'
  echo 'unset AWS_SECURITY_TOKEN'
  echo 'unset AWS_SESSION_TOKEN'
  echo ". <(aws-runas -a '$time' $aws_runas_profile)"
  echo 'aws_id="$(aws sts get-caller-identity)"'
  echo 'export AWS_SIMPLE_ROLENAME="$(echo "$aws_id" | jq -r .Arn 2>&1 | sed "s/.*assumed-role\///" | sed "s/@.*//")"'
  echo 'export AWS_ACCOUNT="$(echo "$aws_id" | jq -r .Account)"'
  echo 'export AWS_ALIAS="$(aws iam list-account-aliases | jq -r '"'"'.AccountAliases[0]'"'"')"'
}

#######################################
# Check for drift
# Arguments:
#   $@
# Returns
#   0 if successfully, non-zero on error.
#######################################
check() {
  if [ -e terragrunt.hcl ]; then

    # Init if needed
    if [ ! -d .terragrunt_cache ]; then
      mkdir -p .terragrunt-cache
      terragrunt init > .terragrunt-cache/output 2>&1
    else
      echo $'\n''TAHO - SKIPPED INIT'$'\n' > .terragrunt-cache/output
    fi

    # Resource count bytes divided by 1024
    s_k="$(( $(terragrunt show -json 2> /dev/null | wc -c) / 1024 ))"

    if \
      terragrunt plan -detailed-exitcode -lock=false \
      >> .terragrunt-cache/output 2>&1
    then
      drift='false'
    else
      drift='true'
    fi
  else
    # Init if needed
    if [ ! -d .terraform ]; then
      mkdir -p .terraform
      terraform init > .terraform/output 2>&1
    else
      echo $'\n''TAHO - SKIPPED INIT'$'\n' > .terraform/output
    fi

    # Resource count bytes divided by 1024
    s_k="$(( $(terraform show -json 2> /dev/null | wc -c) / 1024 ))"

    if \
      terraform plan -detailed-exitcode -lock=false \
      >> .terraform/output 2>&1
    then
      drift='false'
    else
      drift='true'
    fi
  fi
}

#######################################
# Clean the repository
# Arguments:
#   $1 - optional for '-unlock'
# Returns
#   0 if successfully, non-zero on error.
#######################################
clean() {
  (
    cd "$(git rev-parse --show-toplevel)" || exit 1
    find . -name .terraform -type d -exec rm -rf {} \; &> /dev/null
    find . -name .terragrunt-cache -type d -exec rm -rf {} \; &> /dev/null
    if [[ "$1" == '-unlock' ]]; then
      shift
      find . -name .terraform.lock.hcl -type f -delete &> /dev/null
    fi
  )
}

#######################################
# Echo Reverse
# Arguments:
#   $1 - String with lines to reverse.
# Returns
#   0 if successfully, non-zero on error.
#######################################
echo_reverse() {
  local line result nl
  nl=$'\n'
  for line in $(echo "$1"); do
    result="${line}${nl}${result}"
  done
  echo "$result"
}

#######################################
# Garbage Collector
# Arguments:
#   None
# Returns
#   0 if successfully, non-zero on error.
#######################################
gc() {
  rm -rf "$HOME/taho/tmp"
  if git rev-parse --show-toplevel > /dev/null 2>&1; then
    rm -rf "$(git rev-parse --show-toplevel)/.tmp"
  fi
}

#######################################
# Get Context
# Arguments:
#   TBD
# Returns
#   0 if successfully, non-zero on error.
#######################################
get_context() {
  export TF_LOG=''

  local
  start_time="$(now)"

  local c0='\e[0m'
  local c1='\e[31m'
  local c2='\e[32m'
  local c3='\e[35m'
  local c4='\e[36m'
  local c5='\e[34m'
  local c6='\e[93m'
  local c7='\e[103m\e[41m'

  local ctx
  ctx="\n${c2}--- ${c0}${c3}$(
    uname |
    tr '[:lower:]' '[:upper:]' |
    sed 's/DARWIN/MacOS/'
  )${c0} ${c4}($(date "+%m/%d %H:%M"))${c0}\n"

  local aws_ctx
  if [ -z "$AWS_ACCESS_KEY_ID" ]; then
    aws_ctx="${c1}NO-AWS${c0}"
  else
    # Directory for tracking AWS Auth age
    aws_auth_dir="${HOME}/taho/tmp/$HOSTNAME"
    mkdir -p "$aws_auth_dir"

    # File for tracking AWS Auth age
    local aws_auth
    aws_auth="$aws_auth_dir/aws-$AWS_ACCESS_KEY_ID"

    if [ ! -e "$aws_auth" ]; then
      # Auth file did not exist so in our context we consider it to be super
      # old.
      aws_auth_age='999999'
    else
      # Since the auth file exists we can determine it's age now
      if [[ "$(uname)" == 'Darwin' ]]; then
        aws_auth_age="$(gdate -r "$aws_auth" +%s%3N)"
      else
        aws_auth_age="$(date -r "$aws_auth" +%s%3N)"
      fi
      aws_auth_age="$((start_time - aws_auth_age))"
    fi

    # If the age of the auth file is great then five minutes we will check to
    # it using sts to get information and ensure that the auth is still valid.
    if [ "$aws_auth_age" -ge 300000 ]; then

      local assumed_role
      if assumed_role="$(
          set -o pipefail
          aws sts get-caller-identity |
          jq -r .Arn 2>&1 |
          sed "s/.*assumed-role\///" |
          sed "s/@.*//"
        )"
      then
        aws_ctx="${c7} ${assumed_role} ${c0} ${c4}$AWS_ALIAS${c0}"
      else
        aws_ctx="${c5}ERROR${c0}"
      fi

      # Save the auth context so we can re-use it in the future to make the
      # context appear faster.
      {
        echo "$aws_ctx"
      } > "$aws_auth"
    fi

    # Our context uses the auth value from the auth file because much of the
    # time this means we are using a cached value and that is much faster vs.
    # calling aws sts get-caller-identity each time.
    aws_ctx="$(head -n 1 < "$aws_auth")"
  fi

  local git_ctx

  git_ctx="$(
    set -o pipefail
    git remote get-url origin 2>&1 |
    sed 's/.*\///' |
    sed 's/\.git$//'
  )" || git_ctx=''

  if [[ "$git_ctx" != '' ]]; then
    if [ -d .git ]; then
      # clear git_ctx if we are in the git root and the directory name
      # matches the git ctx.
      if [[ "$git_ctx" == "$(pwd | sed 's/.*\///')" ]]; then
        git_ctx=''
      fi
    fi

    if [ -n "$git_ctx" ]; then
      git_ctx="${c1}${git_ctx}${c0} "
    fi

    git_main="$(
      git branch -a --merged 2>&1 |
      grep 'remotes/origin' |
      grep -v 'HEAD ->' |
      sed 's/^ *remotes\/origin\///' |
      grep -E '^(main|master)' |
      head -1
    )"
    git_main="${git_main:-unsure}"

    git_ctx+="${c5}${git_main}${c0}"
    git_ctx+=" ${c3}$(git describe --always)${c0}"

    git_status_ctx="$(
      git status -s 2>&1 |
      wc -l |
      sed 's/ *//'
    )"

    if [[ "$git_status_ctx" != '0' ]]; then
      git_ctx+=" ${c6}(${git_status_ctx} uncommitted)${c0}"
    fi
  else
    git_ctx=''
  fi

  if [[ "$AWS_ACCESS_KEY_ID" != '' ]]; then
    ctx+="${c2}AWS${c0} $aws_ctx\n"
  fi

  if [ -n "$git_ctx" ]; then
    ctx+="${c2}GIT${c0} $git_ctx\n"
  fi

  echo "$ctx"
}

#######################################
# Run lint
# Arguments:
#   None
# Returns
#   0 if successfully, non-zero on error.
#######################################
lint() {
  find . -name \*.md -exec mdl {} \;
  for name in yaml yml; do
    find . -name "*.$name" -exec yamlfmt {} \;
    find . -name "*.$name" -exec yamllint {} \;
  done
  tf_init "$@"
}

#######################################
# Output the time
# Arguments:
#   None
# Returns
#   0 if successfully, non-zero on error.
#######################################
now() {
  local date='date'
  if [[ "$(uname)" == 'Darwin' ]]; then
    date='gdate'
  fi
  $date +%s%3N
}

#######################################
# Process a unit directory
# Arguments:
#   TBD
# Returns
#   0 if successfully, non-zero on error.
#######################################
process_unit() {
  local cmd cmd1 drift enabled n unit
  n="$1"; shift
  count="$1"; shift
  cmd="$1"; shift
  unit="$1"; shift
  SECONDS=0

  if [ -n "$unit" ]; then
    (
      # Set AWS REGION based on unit directory
      dir_segment="$(echo "$unit" | sed 's/\/.*//')"
      case "$dir_segment" in
        _global|eu-west-2|us-east-1)
          AWS_REGION="$dir_segment"
          export AWS_REGION
          ;;
      esac

      # The parent starts at the TAHO_ROOT
      local parent
      parent="${TAHO_ROOT-.}"

      # The parent may or may not be based on $AWS_ALIAS.
      if [ -z "$TAHO_NO_ALIAS_ROOT" ]; then
        parent+="/$AWS_ALIAS"
      fi

      if ! cd "$parent/$unit"; then
        echo -e "\n * ${c2}Could not change directory to '$unit'${c0}\n" >&2
        exit 1
      fi

      mkdir -p .terragrunt-cache

      # Process cmd (level 1)
      cmd1="$cmd"
      local s_k
      case "$cmd1" in
        apply)
          tfg_run 'apply' "$unit" "$@"
          ;;
        check)
          check "$@"
          ;;
        destroy)
          tfg_destroy "$@"
          ;;
        disable)
          tg_unit_enabled "$unit" false
          cmd="$1"; shift
          if [[ "$cmd" == 'apply' ]]; then
            cmd1=''
            tfg_run 'apply' "$unit" "$@"
          fi
          ;;
        enable)
          tg_unit_enabled "$unit" true
          cmd="$1"; shift
          if [[ "$cmd" == 'apply' ]]; then
            cmd1=''
            tfg_run 'apply' "$unit" "$@"
          fi
          ;;
        init)
          if [ -z "$unit" ]; then
            tf_init "$@"
          else
            tfg_run 'init' "$unit" "$@"
          fi
          ;;
      esac

      # Process cmd (level 2)
      case "$cmd1" in
        check|disable|enable|ls)
          tfg_line "$n" "$count" "$drift" "$unit" "$s_k" "$cmd1" "$@"
          ;;
      esac
    )
  fi
}

#######################################
# Run the tf-init subcommand
# Arguments:
#   TBD
# Returns
#   0 if successfully, non-zero on error.
#######################################
tf_init() {
  # If running within docker, we change directory to the workspace.
  if [ -n "$TAHO_DOCKER" ]; then
    cd /workspace || exit 1
  fi

  find . -name main.tf |
  sed 's/\/main.tf//' |
  while read -r module; do
    (
      cd "$module" || exit 1
      echo -e "\n * ${c1}tf init: ${c2}$module${c0}\n" >&2
      terraform init "$@"
      terraform validate
      tflint
    )
  done
}

#######################################
# Run the tf-lint-fix subcommand
# Arguments:
#   None
# Returns
#   0 if successfully, non-zero on error.
#######################################
tf_lint_fix() {
  # If running within docker, we change directory to the workspace.
  if [ -n "$TAHO_DOCKER" ]; then
    cd /workspace || exit 1
  fi

  find . -name main.tf |
  sed 's/\/main.tf//' |
  while read -r module; do
    (
      cd "$module" || exit 1
      echo -e "\n * ${c1}tf lint fix: ${c2}$module${c0}\n" >&2
      tflint --fix
    )
  done
}

#######################################
# Terraform or Terragrunt Destroy
# Arguments:
#   $@ - Subcommands (i.e. -upgrade, or -auto-approve)
# Returns
#   0 if successfully, non-zero on error.
#######################################
tfg_destroy() {
  echo -e "\n * tfg ${c1}destroy:${c2} $unit${c0}\n" >&2
  if [ -e terragrunt.hcl ]; then
    tg_unit_enabled "$unit" false
    terragrunt destroy "$@"
  else
    terraform destroy "$@"
  fi
}

#######################################
# Terraform or Terragrunt run
# Arguments:
#   $@ - Subcommands (i.e. -upgrade, or -auto-approve)
# Returns
#   0 if successfully, non-zero on error.
#######################################
tfg_run() {
  local cmd
  cmd="$1"; shift
  local unit="$1"; shift

  echo -e "\n * tfg ${c1}$cmd:${c2} $unit${c0}\n" >&2

  if [ -e terragrunt.hcl ]; then
    terragrunt "$cmd" "$@"
  else
    terraform "$cmd" "$@"
  fi
}

#######################################
# Show the unit enable state
# Arguments:
#   $1 - number
#   $2 - count
#   $3 - drift
#   $4 - unit
#   $5 - resource count
#   $6 - subcommand
# Returns
#   0 if successfully, non-zero on error.
#######################################
tfg_line() {
  local n="$1"; shift
  local count="$1"; shift
  local drift="$1"; shift
  local unit="$1"; shift
  local s_k="$1"; shift
  local cmd="$1"; shift

  local count_color="${c0}"
  local dependencies_color="${c1}"
  local drift_color="${c0}"
  local enabled_color="${c1}"
  local module_color="${c1}"
  local ref_color="${c1}"
  local s_k_color="${c1}"
  local time_color="${c1}"
  local unit_color="${c1}"

  local enabled
  if [ -e terragrunt.hcl ]; then
    enabled="$(
      grep -E 'unit *= ' terragrunt.hcl |
      sed 's/.*= //' |
      sed 's/ .*//'
    )"
  fi

  if [[ "$enabled" == 'false' ]]; then
    enabled='no'
    dependencies_color="${c0}"
    enabled_color="${c0}"
    module_color="${c0}"
    ref_color="${c0}"
    s_k_color="${c0}"
    time_color="${c0}"
    unit_color="${c0}"
  else
    enabled='yes'
  fi

  if [[ "$cmd" == 'ls' ]]; then
    if [[ "$1" == '-init' ]]; then
      shift
      if [ -e terragrunt.hcl ]; then
        mkdir -p .terragrunt-cache
        terragrunt init "$@" > .terragrunt-cache/output 2>&1
      else
        mkdir -p .terraform
        terraform init "$@" > .terraform/output 2>&1
      fi
    fi
  else
    # Validate the unit
    if [ -e terragrunt.hcl ]; then
      mkdir -p .terragrunt-cache

      if ! terragrunt hcl validate --inputs --strict > /dev/null 2>&1; then
        note+=" terragrunt-is-not-strict"
      fi

    else

      if ! terraform validate > /dev/null 2>&1; then
        note+=" terraform-is-not-valid"
      fi

      if ! tflint > /dev/null 2>&1; then
        note+=" terraform-lint"
      fi

    fi
  fi

  if [[ "$drift" == 'true' ]]; then

    # Determine state
    local show
    if [ -e terragrunt.hcl ]; then
      if ! show="$(terragrunt show -json 2>&1)"; then
        show='terragrunt-show-error'
      fi
    else
      if ! show="$(terraform show -json 2>&1)"; then
        show='terragrunt-show-error'
      fi
    fi

    # A version only block is actually really empty
    if [[ "$show" == '{"format_version":"1.0"}' ]]; then
      show=''
    fi

    # (empty or really empty) means this is a new state.
    if [ -z "$show" ]; then
      drift='new'
    else
      drift='yes'
    fi

    dependencies_color="${c2}"
    drift_color="${c2}"
    enabled_color="${c2}"
    module_color="${c2}"
    ref_color="${c2}"
    s_k_color="${c2}"
    time_color="${c2}"
    unit_color="${c2}"
  else
    drift=''
  fi

  # Track source only for teragrunt
  local source
  if [ -e terragrunt.hcl ]; then

    # Parse the source
    source="$(
      grep -F 'source =' terragrunt.hcl |
      sed 's/.*://' |
      sed 's/"//'
    )"

    # If a source regex is defined use it to transform
    if [ -n "$TAHO_SOURCE_REGEX" ]; then
      source="$(echo "$source" | sed -r "$TAHO_SOURCE_REGEX")"
    fi

    local module
    module="$(
      echo "$source" |
      sed 's/.*\/\///'
    )"

    # Trim source
    source="$(
      echo "$source" |
      sed 's/.*\/\///' |
      sed 's/\?ref=.*//'
    )"

    local ref
    ref="$(
      echo "$module" |
      sed 's/.*\?ref=//' |
      sed 's/".*$//g'
    )"

    module="$(
      echo "$module" |
      sed 's/\?ref=.*//' |
      sed 's/ *//' |
      sed 's/^root\///' |
      sed 's/[^ a-z0-9]*$//g'
    )"

    local note

    dependencies="$(
      grep -E '^dependency' terragrunt.hcl |
      sed -r 's/dependency "//' |
      sed -r 's/".*//' |
      tr '\n' ' ' |
      sed 's/ /, /g' |
      sed -r 's/, $//'
    )"
  fi

  time="$SECONDS"

  if [ -z "$TAHO_NO_DETAIL" ]; then
    local spec=''
    spec="|${count_color}%5s${c0}|"
    spec+="${drift_color}%-3s${c0}|"
    spec+="${enabled_color}%-3s${c0}|"
    spec+="${unit_color}%-50s${c0}|"
    spec+="${module_color}%-28s${c0}|"
    spec+="${ref_color}%11s${c0}|"
    spec+="${dependencies_color}%-40s${c0}|"
    spec+="${s_k_color}%5s${c0}|"
    spec+="${time_color}%5s${c0}|"
    spec+="$note\n"

    local regx
    if [ -n "$TAHO_UNIT_WORKSPACE_DIR" ]; then
      regx="$(echo "$TAHO_UNIT_WORKSPACE_DIR" | sed -r 's/\//\\\//g')"
      unit="$(echo "$unit" | sed -r "s/$regx\\///")"
    fi
    printf "$spec" "$n/$count" "$drift" "$enabled" "$unit" "$module" "$ref" \
      "$dependencies" "$s_k" "$time"
  else
    local spec=''
    spec="|${count_color}%5s${c0}|"
    spec+="${drift_color}%-3s${c0}|"
    spec+="${unit_color}%-102s${c0}|"
    spec+="${s_k_color}%5s${c0}|"
    spec+="${time_color}%5s${c0}|"
    spec+="${c2}$note{$c0}\n"

    printf "$spec" "$n/$count" "$drift" "$unit" "$s_k" "$time"
  fi
}

#######################################
# Set the unit enable state
# Arguments:
#   $1 Unit path
#   $2 Value (true or false)
# Returns
#   0 if successfully, non-zero on error.
#######################################
tg_unit_enabled() {
  local unit="$1"; shift
  local enabled="$1"; shift

  local sed_cfg
  sed_cfg="s/ *unit * = \{ enabled = .* \}/unit = { enabled = $enabled }/g"

  sed -i -r "$sed_cfg" terragrunt.hcl;
  taho fmt > /dev/null
}

#######################################
# Main function
# Arguments:
#   $@ Subcommand (i.e. check, destroy, disable, or enable)
# Returns
#   0 if successfully, non-zero on error.
#######################################
main() {
  mkdir -p "$HOME/taho"

  if [ -z "$TAHO_HOME" ]; then
    # shellcheck disable=SC2012
    TAHO_HOME="$(
      ls -lap "$(which taho)" |
      sed 's/.*> //' |
      sed 's/\/script$//'
    )"
  fi
  export TAHO_HOME

  # Parse the subcommand
  local cmd
  cmd="${1:-shell}"; shift
  if [[ "$cmd" == 'install' ]]; then
    rm -rf /usr/local/bin/taho
    ln -s "$PWD/script" /usr/local/bin/taho
    go install
    echo 'Installed taho'
    exit
  fi

  # Process subcommand (top level)
  local e environment filter n
  case "$cmd" in
    -v|--version)
      taho-go -v
      exit
      ;;
    apply|check|enable|init|ls)
      e='echo'
      ;;
    aws-runas)
      aws_runas "$@"
      ;;
    clean)
      clean "$@"
      exit
      ;;
    destroy|disable)
      e='echo_reverse'
      ;;
    fmt)
      taho-go "$@"
      exit
      ;;
    gc)
      gc "$@"
      exit
      ;;
    get-context)
      get_context "$@"
      exit
      ;;
    tf-init)
      clean
      tf_init "$@"
      exit
      ;;
    tf-lint-fix)
      tf_lint_fix "$@"
      exit
      ;;
    lint)
      clean
      lint "$@"
      ;;
    shell)
      shell "$@"
      exit
      ;;
    start)
      start "$@"
      ;;
    *)
      shell "$cmd"
      exit 1
      ;;
  esac

  # Get the enviornment code (i.e. poc, pro, dev, stg, pre, or prd)
  environment="$1"; shift
  if [ -z "$environment" ]; then
    exit
  fi

  export TAHO_ENVIRONMENT="$environment"
  echo -e "\n${c1} * $cmd:${c2} $environment${c0}\n" >&2
  taho_init="$(git rev-parse --show-toplevel)/.taho.sh"
  if [ -e "$taho_init" ]; then
    source "$taho_init"

    # We may need to source again if the environment was redefined.
    if [[ "$TAHO_ENVIRONMENT" != "$environment" ]]; then
      source "$taho_init"
      environment="$TAHO_ENVIRONMENT"
    fi
  fi

  # If running within docker, we change to the workspace directory.
  if [ -n "$TAHO_DOCKER" ]; then
    cd /workspace || exit 1
  fi

  if [[ "$1" == '-filter' ]]; then
    shift
    filter="$1"
    shift
  else
    filter='.*'
  fi

  if [ -z "$TAHO_NO_DETAIL" ]; then
    export TABLE_LINE='|-----|---|---|--------------------------------------------------|----------------------------|-----------|----------------------------------------|-----|-----|'
  else
    export TABLE_LINE='|-----|---|----------------------------------------------------------------------------------------------------------------------------------------|-----|-----|'
  fi

  if [ -z "$TAHO_DOCKER" ]; then
    workspace="."
  else
    workspace="$(pwd)"
  fi

  # Show header
  e='echo'
  case "$cmd" in
    check|disable|enable|ls)
      printf '|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\n'
      local base="$workspace"
      if [ -n "$TAHO_ROOT" ]; then
        base+="/$TAHO_ROOT"
      fi
      if [ -z "$TAHO_NO_ALIAS_ROOT" ]; then
        printf '|%-158s|\n' "$base/$AWS_ALIAS"
      elif [ -n "$TAHO_UNIT_WORKSPACE_DIR" ]; then
        printf '|%-158s|\n' "$base/$TAHO_UNIT_WORKSPACE_DIR"
      else
        printf '|%-124s|\n' "$base"
      fi
      printf '%s\n' "$TABLE_LINE"
      if [ -z "$TAHO_NO_DETAIL" ]; then
        printf '|%5s|%-3s|%-3s|%-50s|%-28s|%11s|%-40s|%5s|%5s|\n' N. DFT EN UNIT MODULE REFERENCE DEPENDENCIES 'S (k)' TIME
      else
        printf '|%5s|%-3s|%-102s|%5s|%5s|\n' N. DFT UNIT 'S (k)' TIME
      fi
      printf '%s\n' "$TABLE_LINE"
      ;;
  esac

  # The infrastructure may or may not be under $AWS_ALIAS
  local env_filter
  if [ -z "$TAHO_NO_ALIAS_ROOT" ]; then
    env_filter="/$environment/"
  else
    env_filter="${TAHO_ENV_FILTER_PREFIX}$environment/"
  fi

  # Reads the list of units from the table in our README.
  if [ -z "$TAHO_REGX" ]; then
    TAHO_REGX='(_global|eu-west-2|us-east-1)'
  fi
  local regx="^\|\`$TAHO_REGX/"
  TAHO_UNITS="$(
    grep -E "$regx" "$(git rev-parse --show-toplevel)/README.md" |
    sed 's/^|`//' |
    sed 's/`.*//'
  )"

  TAHO_UNITS="$(
    echo "$TAHO_UNITS" |
    grep -E "$filter"
  )"

  TAHO_UNITS="$(
    echo "$TAHO_UNITS" |
    grep -F "$env_filter"
  )"

  # Start counter at zero
  n=0
  count="$(echo "$TAHO_UNITS" | wc -l)"

  # Process the subcommand
  "$e" "$TAHO_UNITS" |
  while read -r unit; do
    n=$(( n + 1 ))
    process_unit "$n" "$count" "$cmd" "$unit" "$@"
  done

  # Show footer
  e='echo'
  case "$cmd" in
    check|disable|enable|ls)
      printf '%s\n' "$TABLE_LINE"
      ;;
  esac

  # A final line for readability
  echo
}

#######################################
# Run the Console subcommand
# Arguments:
#   TBD
# Returns
#   0 if successfully, non-zero on error.
#######################################
shell() {
  local taho_id
  taho_id="$(uuidgen)"

  # Make sure that .tmp exists.
  mkdir -p "$(git rev-parse --show-toplevel)/.tmp"

  # If this appears to be the first running for the first time we set TAHO_VERBOSE.
  if [ ! -e "$HOME/taho/.gitconfig" ]; then
    TAHO_VERBOSE=true
  fi

  # Use linux/amd64
  export DOCKER_DEFAULT_PLATFORM='linux/amd64'

  # Capture the current working directory
  local working_dir="$PWD"

  # Change directory to toplevel
  cd "$(git rev-parse --show-toplevel)" || exit 1

  # Build
  if [[ "$1" == '-V' ]]; then
    export TAHO_VERBOSE=true
    shift
  fi

  (
    cd "$TAHO_HOME" || exit 1
    db="docker build . -t taho"
    if [ -z "$TAHO_VERBOSE" ]; then
      db+=' > /dev/null 2>&1'
    fi
    eval "$db"
  )

  (
    echo $'#!/bin/bash\n'
    echo "cd '.$(
      echo "$working_dir" |
      sed 's/'"$(
        pwd |
        sed 's/\//\\\//g'
      )"'//'
    )'"
    echo 'export PATH="$HOME/.tfenv/bin:$PATH"'
    echo 'export PATH="$HOME/.tgenv/bin:$PATH"'
    echo 'export PATH="$HOME/go/bin:$PATH"'
    echo 'history -c'
    echo 'cat /root/.history >> /root/.history-x'
    if [ -z "$1" ]; then
      echo "zsh -c 'source /root/.zshrc; zsh'; cat /root/.history-x >> /root/.history"
    else
      echo "zsh -c 'source /root/.zshrc; $*'"
    fi
  ) > ".tmp/start-$taho_id"
  chmod +x ".tmp/start-$taho_id"

  # Ensure that required file system resources exist.
  existing_or "$HOME/.cache/pre-commit"         'mkdir -p'
  existing_or "$HOME/.terraform.d/plugin-cache" 'mkdir -p'
  existing_or "$HOME/.terraformrc"              'touch'
  existing_or "$PWD/.tmp/history"               'touch'

  # Create a docker subcommand
  local d
  d='time docker run --rm -it'
  d+=' -e TAHO_DOCKER=true'
  d+=" -h '$(basename "$PWD")'"
  d+=" -v '$HOME/.ssh:/root/.ssh'"
  d+=" -v '$PWD:/workspace'"
  d+=" -v '$PWD/.tmp/history:/root/.history:rw'"

  # Add volume mounts to the docker subcommand
  for x in \
    '.cache/pre-commit' \
    '.ssh/known_hosts'
  do
    d+=" -v '$HOME/$x:/root/$x'"
  done

  sed -r 's/\tgpgsign = true/\tgpgsign = false/' \
    < "$HOME/.gitconfig" > "$HOME/taho/.gitconfig"

  mkdir -p "$HOME/taho"
  d+=" -v '$HOME/taho/.gitconfig:/root/.gitconfig'"

  # Add rw volume mounts to the docker subcommand
  for x in \
    '.terraform.d/plugin-cache' \
    '.terraformrc' \
    '.aws'
  do
    d+=" -v '$HOME/$x:/root/$x:rw'"
  done

  # Add environment variables to the docker subcommand
  for v in $(
    env |
    grep -E '^(AWS_)' |
    sed 's/=.*//' \
  ); do
    d+=" -e $v"
  done

  # Evaluate the docker subcommand
  eval "$d taho './.tmp/start-$taho_id'"
  rm "./.tmp/start-$taho_id"
}

# Define a function for exist or evaluate
existing_or() {
  [ -e "$1" ] || eval "$2 $1"
}

#######################################
# Run the start subcommand
# Arguments:
#   TBD
# Returns
#   0 if successfully, non-zero on error.
#######################################
start() {
  for profile in $(grep -F '[profile ' < "$HOME/.aws/config" |
    sed 's/.* //' |
    sed 's/\]//'
  ); do
    echo "alias \"taho-aws-$profile\"=\". <(taho aws-runas $profile)\""
  done

  if [[ "$(uname)" == 'Darwin' ]]; then
    echo "alias taho-git-delete-and-push-back='git push origin \":\$(git branch --show-current)\"; git push -u origin HEAD'"

    echo   "taho-git-commit() {"
    echo   "  local issue"
    echo   "  issue=\"\$(git branch --show-current)\""
    printf "  git commit -m\"\$1\\n\\n\$2\" --trailer \"issue: \$issue\" && git commit --amend"
    echo   "}"
    echo   "taho_precmd() {"
    echo   "  echo -e -n \"\$(taho get-context)\""
    echo   "}"
    echo   "add-zsh-hook precmd taho_precmd"
  fi

  if [ -e .taho.sh ]; then
    source .taho.sh
  fi

  echo "$TAHO_ALIASES"
}

main "$@"
